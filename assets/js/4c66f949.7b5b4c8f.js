"use strict";(self.webpackChunkreact_query_web_i18n=self.webpackChunkreact_query_web_i18n||[]).push([[7038],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function u(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),s=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=s(e.components);return a.createElement(o.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},y=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,p=u(e,["components","mdxType","originalType","parentName"]),c=s(n),y=r,m=c["".concat(o,".").concat(y)]||c[y]||d[y]||i;return n?a.createElement(m,l(l({ref:t},p),{},{components:n})):a.createElement(m,l({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=y;var u={};for(var o in t)hasOwnProperty.call(t,o)&&(u[o]=t[o]);u.originalType=e,u[c]="string"==typeof e?e:r,l[1]=u;for(var s=2;s<i;s++)l[s]=n[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}y.displayName="MDXCreateElement"},944:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>u,toc:()=>s});var a=n(7462),r=(n(7294),n(3905));const i={id:"QueryClient",title:"QueryClient"},l=void 0,u={unversionedId:"reference/QueryClient",id:"reference/QueryClient",title:"QueryClient",description:"QueryClient",source:"@site/react/reference/QueryClient.md",sourceDirName:"reference",slug:"/reference/QueryClient",permalink:"/react-query-web-i18n/react/reference/QueryClient",draft:!1,editUrl:"https://github.com/cangSDARM/react-query-web-i18n/blob/master/react/reference/QueryClient.md",tags:[],version:"current",lastUpdatedAt:1682671237,formattedLastUpdatedAt:"Apr 28, 2023",frontMatter:{id:"QueryClient",title:"QueryClient"}},o={},s=[{value:"<code>QueryClient</code>",id:"queryclient",level:2},{value:"<code>queryClient.fetchQuery</code>",id:"queryclientfetchquery",level:2},{value:"<code>queryClient.fetchInfiniteQuery</code>",id:"queryclientfetchinfinitequery",level:2},{value:"<code>queryClient.prefetchQuery</code>",id:"queryclientprefetchquery",level:2},{value:"<code>queryClient.prefetchInfiniteQuery</code>",id:"queryclientprefetchinfinitequery",level:2},{value:"<code>queryClient.getQueryData</code>",id:"queryclientgetquerydata",level:2},{value:"<code>queryClient.getQueriesData</code>",id:"queryclientgetqueriesdata",level:2},{value:"<code>queryClient.setQueryData</code>",id:"queryclientsetquerydata",level:2},{value:"<code>queryClient.getQueryState</code>",id:"queryclientgetquerystate",level:2},{value:"<code>queryClient.setQueriesData</code>",id:"queryclientsetqueriesdata",level:2},{value:"<code>queryClient.invalidateQueries</code>",id:"queryclientinvalidatequeries",level:2},{value:"<code>queryClient.refetchQueries</code>",id:"queryclientrefetchqueries",level:2},{value:"<code>queryClient.cancelQueries</code>",id:"queryclientcancelqueries",level:2},{value:"<code>queryClient.removeQueries</code>",id:"queryclientremovequeries",level:2},{value:"<code>queryClient.resetQueries</code>",id:"queryclientresetqueries",level:2},{value:"<code>queryClient.isFetching</code>",id:"queryclientisfetching",level:2},{value:"<code>queryClient.isMutating</code>",id:"queryclientismutating",level:2},{value:"<code>queryClient.getLogger</code>",id:"queryclientgetlogger",level:2},{value:"<code>queryClient.getDefaultOptions</code>",id:"queryclientgetdefaultoptions",level:2},{value:"<code>queryClient.setDefaultOptions</code>",id:"queryclientsetdefaultoptions",level:2},{value:"<code>queryClient.getQueryDefaults</code>",id:"queryclientgetquerydefaults",level:2},{value:"<code>queryClient.setQueryDefaults</code>",id:"queryclientsetquerydefaults",level:2},{value:"<code>queryClient.getMutationDefaults</code>",id:"queryclientgetmutationdefaults",level:2},{value:"<code>queryClient.setMutationDefaults</code>",id:"queryclientsetmutationdefaults",level:2},{value:"<code>queryClient.getQueryCache</code>",id:"queryclientgetquerycache",level:2},{value:"<code>queryClient.getMutationCache</code>",id:"queryclientgetmutationcache",level:2},{value:"<code>queryClient.clear</code>",id:"queryclientclear",level:2},{value:"<code>queryClient.resumePausedMutations</code>",id:"queryclientresumepausedmutations",level:2}],p={toc:s},c="wrapper";function d(e){let{components:t,...n}=e;return(0,r.kt)(c,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"queryclient"},(0,r.kt)("inlineCode",{parentName:"h2"},"QueryClient")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"QueryClient")," can be used to interact with a cache:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},'import { QueryClient } from "@tanstack/react-query";\n\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      staleTime: Infinity,\n    },\n  },\n});\n\nawait queryClient.prefetchQuery(["posts"], fetchPosts);\n')),(0,r.kt)("p",null,"Its available methods are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#queryclient"},(0,r.kt)("inlineCode",{parentName:"a"},"QueryClient"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#queryclientfetchquery"},(0,r.kt)("inlineCode",{parentName:"a"},"queryClient.fetchQuery"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#queryclientfetchinfinitequery"},(0,r.kt)("inlineCode",{parentName:"a"},"queryClient.fetchInfiniteQuery"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#queryclientprefetchquery"},(0,r.kt)("inlineCode",{parentName:"a"},"queryClient.prefetchQuery"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#queryclientprefetchinfinitequery"},(0,r.kt)("inlineCode",{parentName:"a"},"queryClient.prefetchInfiniteQuery"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#queryclientgetquerydata"},(0,r.kt)("inlineCode",{parentName:"a"},"queryClient.getQueryData"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#queryclientgetqueriesdata"},(0,r.kt)("inlineCode",{parentName:"a"},"queryClient.getQueriesData"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#queryclientsetquerydata"},(0,r.kt)("inlineCode",{parentName:"a"},"queryClient.setQueryData"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#queryclientgetquerystate"},(0,r.kt)("inlineCode",{parentName:"a"},"queryClient.getQueryState"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#queryclientsetqueriesdata"},(0,r.kt)("inlineCode",{parentName:"a"},"queryClient.setQueriesData"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#queryclientinvalidatequeries"},(0,r.kt)("inlineCode",{parentName:"a"},"queryClient.invalidateQueries"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#queryclientrefetchqueries"},(0,r.kt)("inlineCode",{parentName:"a"},"queryClient.refetchQueries"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#queryclientcancelqueries"},(0,r.kt)("inlineCode",{parentName:"a"},"queryClient.cancelQueries"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#queryclientremovequeries"},(0,r.kt)("inlineCode",{parentName:"a"},"queryClient.removeQueries"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#queryclientresetqueries"},(0,r.kt)("inlineCode",{parentName:"a"},"queryClient.resetQueries"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#queryclientisfetching"},(0,r.kt)("inlineCode",{parentName:"a"},"queryClient.isFetching"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#queryclientismutating"},(0,r.kt)("inlineCode",{parentName:"a"},"queryClient.isMutating"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#queryclientgetlogger"},(0,r.kt)("inlineCode",{parentName:"a"},"queryClient.getLogger"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#queryclientgetdefaultoptions"},(0,r.kt)("inlineCode",{parentName:"a"},"queryClient.getDefaultOptions"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#queryclientsetdefaultoptions"},(0,r.kt)("inlineCode",{parentName:"a"},"queryClient.setDefaultOptions"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#queryclientgetquerydefaults"},(0,r.kt)("inlineCode",{parentName:"a"},"queryClient.getQueryDefaults"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#queryclientsetquerydefaults"},(0,r.kt)("inlineCode",{parentName:"a"},"queryClient.setQueryDefaults"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#queryclientgetmutationdefaults"},(0,r.kt)("inlineCode",{parentName:"a"},"queryClient.getMutationDefaults"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#queryclientsetmutationdefaults"},(0,r.kt)("inlineCode",{parentName:"a"},"queryClient.setMutationDefaults"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#queryclientgetquerycache"},(0,r.kt)("inlineCode",{parentName:"a"},"queryClient.getQueryCache"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#queryclientgetmutationcache"},(0,r.kt)("inlineCode",{parentName:"a"},"queryClient.getMutationCache"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#queryclientclear"},(0,r.kt)("inlineCode",{parentName:"a"},"queryClient.clear"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#queryclientresumepausedmutations"},(0,r.kt)("inlineCode",{parentName:"a"},"queryClient.resumePausedMutations")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Options")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"queryCache?: QueryCache"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Optional"),(0,r.kt)("li",{parentName:"ul"},"The query cache this client is connected to."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"mutationCache?: MutationCache"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Optional"),(0,r.kt)("li",{parentName:"ul"},"The mutation cache this client is connected to."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"logger?: Logger"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Optional"),(0,r.kt)("li",{parentName:"ul"},"The logger this client uses to log debugging information, warnings and errors. If not set, ",(0,r.kt)("inlineCode",{parentName:"li"},"console")," is the default logger."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"defaultOptions?: DefaultOptions"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Optional"),(0,r.kt)("li",{parentName:"ul"},"Define defaults for all queries and mutations using this queryClient.")))),(0,r.kt)("h2",{id:"queryclientfetchquery"},(0,r.kt)("inlineCode",{parentName:"h2"},"queryClient.fetchQuery")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"fetchQuery")," is an asynchronous method that can be used to fetch and cache a query. It will either resolve with the data or throw with the error. Use the ",(0,r.kt)("inlineCode",{parentName:"p"},"prefetchQuery")," method if you just want to fetch a query without needing the result."),(0,r.kt)("p",null,"If the query exists and the data is not invalidated or older than the given ",(0,r.kt)("inlineCode",{parentName:"p"},"staleTime"),", then the data from the cache will be returned. Otherwise it will try to fetch the latest data."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"The difference between using ",(0,r.kt)("inlineCode",{parentName:"p"},"fetchQuery")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"setQueryData")," is that ",(0,r.kt)("inlineCode",{parentName:"p"},"fetchQuery")," is async and will ensure that duplicate requests for this query are not created with ",(0,r.kt)("inlineCode",{parentName:"p"},"useQuery")," instances for the same query are rendered while the data is fetching.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"try {\n  const data = await queryClient.fetchQuery(queryKey, queryFn);\n} catch (error) {\n  console.log(error);\n}\n")),(0,r.kt)("p",null,"Specify a ",(0,r.kt)("inlineCode",{parentName:"p"},"staleTime")," to only fetch when the data is older than a certain amount of time:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"try {\n  const data = await queryClient.fetchQuery(queryKey, queryFn, {\n    staleTime: 10000,\n  });\n} catch (error) {\n  console.log(error);\n}\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Options")),(0,r.kt)("p",null,"The options for ",(0,r.kt)("inlineCode",{parentName:"p"},"fetchQuery")," are exactly the same as those of ",(0,r.kt)("a",{parentName:"p",href:"../reference/useQuery"},(0,r.kt)("inlineCode",{parentName:"a"},"useQuery")),", except the following: ",(0,r.kt)("inlineCode",{parentName:"p"},"enabled, refetchInterval, refetchIntervalInBackground, refetchOnWindowFocus, refetchOnReconnect, notifyOnChangeProps, onSuccess, onError, onSettled, useErrorBoundary, select, suspense, keepPreviousData, placeholderData"),"; which are strictly for useQuery and useInfiniteQuery. You can check the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/tannerlinsley/react-query/blob/361935a12cec6f36d0bd6ba12e84136c405047c5/src/core/types.ts#L83"},"source code")," for more clarity."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Promise<TData>"))),(0,r.kt)("h2",{id:"queryclientfetchinfinitequery"},(0,r.kt)("inlineCode",{parentName:"h2"},"queryClient.fetchInfiniteQuery")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"fetchInfiniteQuery")," is similar to ",(0,r.kt)("inlineCode",{parentName:"p"},"fetchQuery")," but can be used to fetch and cache an infinite query."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"try {\n  const data = await queryClient.fetchInfiniteQuery(queryKey, queryFn);\n  console.log(data.pages);\n} catch (error) {\n  console.log(error);\n}\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Options")),(0,r.kt)("p",null,"The options for ",(0,r.kt)("inlineCode",{parentName:"p"},"fetchInfiniteQuery")," are exactly the same as those of ",(0,r.kt)("a",{parentName:"p",href:"#queryclientfetchquery"},(0,r.kt)("inlineCode",{parentName:"a"},"fetchQuery")),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Promise<InfiniteData<TData>>"))),(0,r.kt)("h2",{id:"queryclientprefetchquery"},(0,r.kt)("inlineCode",{parentName:"h2"},"queryClient.prefetchQuery")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"prefetchQuery")," is an asynchronous method that can be used to prefetch a query before it is needed or rendered with ",(0,r.kt)("inlineCode",{parentName:"p"},"useQuery")," and friends. The method works the same as ",(0,r.kt)("inlineCode",{parentName:"p"},"fetchQuery")," except that it will not throw or return any data."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"await queryClient.prefetchQuery(queryKey, queryFn);\n")),(0,r.kt)("p",null,"You can even use it with a default queryFn in your config!"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"await queryClient.prefetchQuery(queryKey);\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Options")),(0,r.kt)("p",null,"The options for ",(0,r.kt)("inlineCode",{parentName:"p"},"prefetchQuery")," are exactly the same as those of ",(0,r.kt)("a",{parentName:"p",href:"#queryclientfetchquery"},(0,r.kt)("inlineCode",{parentName:"a"},"fetchQuery")),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Promise<void>"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"A promise is returned that will either immediately resolve if no fetch is needed or after the query has been executed. It will not return any data or throw any errors.")))),(0,r.kt)("h2",{id:"queryclientprefetchinfinitequery"},(0,r.kt)("inlineCode",{parentName:"h2"},"queryClient.prefetchInfiniteQuery")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"prefetchInfiniteQuery")," is similar to ",(0,r.kt)("inlineCode",{parentName:"p"},"prefetchQuery")," but can be used to prefetch and cache an infinite query."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"await queryClient.prefetchInfiniteQuery(queryKey, queryFn);\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Options")),(0,r.kt)("p",null,"The options for ",(0,r.kt)("inlineCode",{parentName:"p"},"prefetchInfiniteQuery")," are exactly the same as those of ",(0,r.kt)("a",{parentName:"p",href:"#queryclientfetchquery"},(0,r.kt)("inlineCode",{parentName:"a"},"fetchQuery")),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Promise<void>"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"A promise is returned that will either immediately resolve if no fetch is needed or after the query has been executed. It will not return any data or throw any errors.")))),(0,r.kt)("h2",{id:"queryclientgetquerydata"},(0,r.kt)("inlineCode",{parentName:"h2"},"queryClient.getQueryData")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"getQueryData")," is a synchronous function that can be used to get an existing query's cached data. If the query does not exist, ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined")," will be returned."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const data = queryClient.getQueryData(queryKey);\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Options")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"queryKey?: QueryKey"),": ",(0,r.kt)("a",{parentName:"li",href:"/react-query-web-i18n/react/guides&concepts/query-keys"},"Query Keys")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"filters?: QueryFilters"),": ",(0,r.kt)("a",{parentName:"li",href:"/react-query-web-i18n/react/guides&concepts/filters#query-filters"},"Query Filters"))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"data: TData | undefined"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The data for the cached query, or ",(0,r.kt)("inlineCode",{parentName:"li"},"undefined")," if the query does not exist.")))),(0,r.kt)("h2",{id:"queryclientgetqueriesdata"},(0,r.kt)("inlineCode",{parentName:"h2"},"queryClient.getQueriesData")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"getQueriesData")," is a synchronous function that can be used to get the cached data of multiple queries. Only queries that match the passed queryKey or queryFilter will be returned. If there are no matching queries, an empty array will be returned."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const data = queryClient.getQueriesData(queryKey | filters);\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Options")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"queryKey: QueryKey"),": ",(0,r.kt)("a",{parentName:"li",href:"/react-query-web-i18n/react/guides&concepts/query-keys"},"Query Keys")," | ",(0,r.kt)("inlineCode",{parentName:"li"},"filters: QueryFilters"),": ",(0,r.kt)("a",{parentName:"li",href:"/react-query-web-i18n/react/guides&concepts/filters#query-filters"},"Query Filters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"if a queryKey is passed as the argument, the data with queryKeys fuzzily matching this param will be returned"),(0,r.kt)("li",{parentName:"ul"},"if a filter is passed, the data with queryKeys matching the filter will be returned")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"[queryKey:QueryKey, data:TData | unknown][]"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"An array of tuples for the matched query keys, or ",(0,r.kt)("inlineCode",{parentName:"li"},"[]")," if there are no matches. The tuples are the query key and its associated data.")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Caveats")),(0,r.kt)("p",null,'Because the returned data in each tuple can be of varying structures (i.e. using a filter to return "active" queries can return different data types), the ',(0,r.kt)("inlineCode",{parentName:"p"},"TData")," generic defaults to ",(0,r.kt)("inlineCode",{parentName:"p"},"unknown"),". If you provide a more specific type to ",(0,r.kt)("inlineCode",{parentName:"p"},"TData")," it is assumed that you are certain each tuple's data entry is all the same type."),(0,r.kt)("p",null,'This distinction is more a "convenience" for ts devs that know which structure will be returned.'),(0,r.kt)("h2",{id:"queryclientsetquerydata"},(0,r.kt)("inlineCode",{parentName:"h2"},"queryClient.setQueryData")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"setQueryData")," is a synchronous function that can be used to immediately update a query's cached data. If the query does not exist, it will be created. ",(0,r.kt)("strong",{parentName:"p"},"If the query is not utilized by a query hook in the default ",(0,r.kt)("inlineCode",{parentName:"strong"},"cacheTime")," of 5 minutes, the query will be garbage collected"),". To update multiple queries at once and match query keys partially, you need to use ",(0,r.kt)("a",{parentName:"p",href:"#queryclientsetqueriesdata"},(0,r.kt)("inlineCode",{parentName:"a"},"queryClient.setQueriesData"))," instead."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"The difference between using ",(0,r.kt)("inlineCode",{parentName:"p"},"setQueryData")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"fetchQuery")," is that ",(0,r.kt)("inlineCode",{parentName:"p"},"setQueryData")," is sync and assumes that you already synchronously have the data available. If you need to fetch the data asynchronously, it's suggested that you either refetch the query key or use ",(0,r.kt)("inlineCode",{parentName:"p"},"fetchQuery")," to handle the asynchronous fetch.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"queryClient.setQueryData(queryKey, updater);\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Options")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"queryKey: QueryKey"),": ",(0,r.kt)("a",{parentName:"li",href:"/react-query-web-i18n/react/guides&concepts/query-keys"},"Query Keys")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"updater: TData | (oldData: TData | undefined) => TData | undefined"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"If non-function is passed, the data will be updated to this value"),(0,r.kt)("li",{parentName:"ul"},"If a function is passed, it will receive the old data value and be expected to return a new one.")))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Using an updater value")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"setQueryData(queryKey, newData);\n")),(0,r.kt)("p",null,"If the value is ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined"),", the query data is not updated."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Using an updater function")),(0,r.kt)("p",null,"For convenience in syntax, you can also pass an updater function which receives the current data value and returns the new one:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"setQueryData(queryKey, (oldData) => newData);\n")),(0,r.kt)("p",null,"If the updater function returns ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined"),", the query data will not be updated. If the updater function receives ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined")," as input, you can return ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined")," to bail out of the update and thus ",(0,r.kt)("em",{parentName:"p"},"not")," create a new cache entry."),(0,r.kt)("h2",{id:"queryclientgetquerystate"},(0,r.kt)("inlineCode",{parentName:"h2"},"queryClient.getQueryState")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"getQueryState")," is a synchronous function that can be used to get an existing query's state. If the query does not exist, ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined")," will be returned."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const state = queryClient.getQueryState(queryKey);\nconsole.log(state.dataUpdatedAt);\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Options")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"queryKey?: QueryKey"),": ",(0,r.kt)("a",{parentName:"li",href:"/react-query-web-i18n/react/guides&concepts/query-keys"},"Query Keys")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"filters?: QueryFilters"),": ",(0,r.kt)("a",{parentName:"li",href:"/react-query-web-i18n/react/guides&concepts/filters#query-filters"},"Query Filters"))),(0,r.kt)("h2",{id:"queryclientsetqueriesdata"},(0,r.kt)("inlineCode",{parentName:"h2"},"queryClient.setQueriesData")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"setQueriesData")," is a synchronous function that can be used to immediately update cached data of multiple queries by using filter function or partially matching the query key. Only queries that match the passed queryKey or queryFilter will be updated - no new cache entries will be created. Under the hood, ",(0,r.kt)("a",{parentName:"p",href:"#queryclientsetquerydata"},(0,r.kt)("inlineCode",{parentName:"a"},"setQueryData"))," is called for each query."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"queryClient.setQueriesData(queryKey | filters, updater);\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Options")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"queryKey: QueryKey"),": ",(0,r.kt)("a",{parentName:"li",href:"/react-query-web-i18n/react/guides&concepts/query-keys"},"Query Keys")," | ",(0,r.kt)("inlineCode",{parentName:"li"},"filters: QueryFilters"),": ",(0,r.kt)("a",{parentName:"li",href:"/react-query-web-i18n/react/guides&concepts/filters#query-filters"},"Query Filters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"if a queryKey is passed as first argument, queryKeys partially matching this param will be updated"),(0,r.kt)("li",{parentName:"ul"},"if a filter is passed, queryKeys matching the filter will be updated"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"updater: TData | (oldData: TData | undefined) => TData"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"the ",(0,r.kt)("a",{parentName:"li",href:"#queryclientsetquerydata"},"setQueryData")," updater function or new data, will be called for each matching queryKey")))),(0,r.kt)("h2",{id:"queryclientinvalidatequeries"},(0,r.kt)("inlineCode",{parentName:"h2"},"queryClient.invalidateQueries")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"invalidateQueries")," method can be used to invalidate and refetch single or multiple queries in the cache based on their query keys or any other functionally accessible property/state of the query. By default, all matching queries are immediately marked as invalid and active queries are refetched in the background."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If you ",(0,r.kt)("strong",{parentName:"li"},"do not want active queries to refetch"),", and simply be marked as invalid, you can use the ",(0,r.kt)("inlineCode",{parentName:"li"},"refetchType: 'none'")," option."),(0,r.kt)("li",{parentName:"ul"},"If you ",(0,r.kt)("strong",{parentName:"li"},"want inactive queries to refetch")," as well, use the ",(0,r.kt)("inlineCode",{parentName:"li"},"refetchTye: 'all'")," option")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},'await queryClient.invalidateQueries(\n  ["posts"],\n  {\n    exact,\n    refetchType: "active",\n  },\n  { throwOnError, cancelRefetch },\n);\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Options")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"queryKey?: QueryKey"),": ",(0,r.kt)("a",{parentName:"li",href:"/react-query-web-i18n/react/guides&concepts/query-keys"},"Query Keys")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"filters?: QueryFilters"),": ",(0,r.kt)("a",{parentName:"li",href:"/react-query-web-i18n/react/guides&concepts/filters#query-filters"},"Query Filters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"refetchType?: 'active' | 'inactive' | 'all' | 'none'"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Defaults to ",(0,r.kt)("inlineCode",{parentName:"li"},"'active'")),(0,r.kt)("li",{parentName:"ul"},"When set to ",(0,r.kt)("inlineCode",{parentName:"li"},"active"),", only queries that match the refetch predicate and are actively being rendered via ",(0,r.kt)("inlineCode",{parentName:"li"},"useQuery")," and friends will be refetched in the background."),(0,r.kt)("li",{parentName:"ul"},"When set to ",(0,r.kt)("inlineCode",{parentName:"li"},"inactive"),", only queries that match the refetch predicate and are NOT actively being rendered via ",(0,r.kt)("inlineCode",{parentName:"li"},"useQuery")," and friends will be refetched in the background."),(0,r.kt)("li",{parentName:"ul"},"When set to ",(0,r.kt)("inlineCode",{parentName:"li"},"all"),", all queries that match the refetch predicate will be refetched in the background."),(0,r.kt)("li",{parentName:"ul"},"When set to ",(0,r.kt)("inlineCode",{parentName:"li"},"none"),", no queries will be refetched, and those that match the refetch predicate will be marked as invalid only."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"refetchPage: (page: TData, index: number, allPages: TData[]) => boolean"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Only for ",(0,r.kt)("a",{parentName:"li",href:"/react-query-web-i18n/react/guides&concepts/infinite-queries#refetchpage"},"Infinite Queries")),(0,r.kt)("li",{parentName:"ul"},"Use this function to specify which pages should be refetched"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"options?: InvalidateOptions"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"throwOnError?: boolean"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"When set to ",(0,r.kt)("inlineCode",{parentName:"li"},"true"),", this method will throw if any of the query refetch tasks fail."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"cancelRefetch?: boolean"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Defaults to ",(0,r.kt)("inlineCode",{parentName:"li"},"true"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Per default, a currently running request will be cancelled before a new request is made"))),(0,r.kt)("li",{parentName:"ul"},"When set to ",(0,r.kt)("inlineCode",{parentName:"li"},"false"),", no refetch will be made if there is already a request running.")))))),(0,r.kt)("h2",{id:"queryclientrefetchqueries"},(0,r.kt)("inlineCode",{parentName:"h2"},"queryClient.refetchQueries")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"refetchQueries")," method can be used to refetch queries based on certain conditions."),(0,r.kt)("p",null,"Examples:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},'// refetch all queries:\nawait queryClient.refetchQueries();\n\n// refetch all stale queries:\nawait queryClient.refetchQueries({ stale: true });\n\n// refetch all active queries partially matching a query key:\nawait queryClient.refetchQueries(["posts"], { type: "active" });\n\n// refetch all active queries exactly matching a query key:\nawait queryClient.refetchQueries(["posts", 1], { type: "active", exact: true });\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Options")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"queryKey?: QueryKey"),": ",(0,r.kt)("a",{parentName:"li",href:"/react-query-web-i18n/react/guides&concepts/query-keys"},"Query Keys")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"filters?: QueryFilters"),": ",(0,r.kt)("a",{parentName:"li",href:"/react-query-web-i18n/react/guides&concepts/filters#query-filters"},"Query Filters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"refetchPage: (page: TData, index: number, allPages: TData[]) => boolean"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Only for ",(0,r.kt)("a",{parentName:"li",href:"/react-query-web-i18n/react/guides&concepts/infinite-queries#refetchpage"},"Infinite Queries")),(0,r.kt)("li",{parentName:"ul"},"Use this function to specify which pages should be refetched"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"options?: RefetchOptions"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"throwOnError?: boolean"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"When set to ",(0,r.kt)("inlineCode",{parentName:"li"},"true"),", this method will throw if any of the query refetch tasks fail."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"cancelRefetch?: boolean"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Defaults to ",(0,r.kt)("inlineCode",{parentName:"li"},"true"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Per default, a currently running request will be cancelled before a new request is made"))),(0,r.kt)("li",{parentName:"ul"},"When set to ",(0,r.kt)("inlineCode",{parentName:"li"},"false"),", no refetch will be made if there is already a request running.")))))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns")),(0,r.kt)("p",null,"This function returns a promise that will resolve when all of the queries are done being refetched. By default, it ",(0,r.kt)("strong",{parentName:"p"},"will not")," throw an error if any of those queries refetches fail, but this can be configured by setting the ",(0,r.kt)("inlineCode",{parentName:"p"},"throwOnError")," option to ",(0,r.kt)("inlineCode",{parentName:"p"},"true")),(0,r.kt)("h2",{id:"queryclientcancelqueries"},(0,r.kt)("inlineCode",{parentName:"h2"},"queryClient.cancelQueries")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"cancelQueries")," method can be used to cancel outgoing queries based on their query keys or any other functionally accessible property/state of the query."),(0,r.kt)("p",null,"This is most useful when performing optimistic updates since you will likely need to cancel any outgoing query refetches so they don't clobber your optimistic update when they resolve."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},'await queryClient.cancelQueries(["posts"], { exact: true });\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Options")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"queryKey?: QueryKey"),": ",(0,r.kt)("a",{parentName:"li",href:"/react-query-web-i18n/react/guides&concepts/query-keys"},"Query Keys")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"filters?: QueryFilters"),": ",(0,r.kt)("a",{parentName:"li",href:"/react-query-web-i18n/react/guides&concepts/filters#query-filters"},"Query Filters"))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns")),(0,r.kt)("p",null,"This method does not return anything"),(0,r.kt)("h2",{id:"queryclientremovequeries"},(0,r.kt)("inlineCode",{parentName:"h2"},"queryClient.removeQueries")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"removeQueries")," method can be used to remove queries from the cache based on their query keys or any other functionally accessible property/state of the query."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"queryClient.removeQueries(queryKey, { exact: true });\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Options")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"queryKey?: QueryKey"),": ",(0,r.kt)("a",{parentName:"li",href:"/react-query-web-i18n/react/guides&concepts/query-keys"},"Query Keys")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"filters?: QueryFilters"),": ",(0,r.kt)("a",{parentName:"li",href:"/react-query-web-i18n/react/guides&concepts/filters#query-filters"},"Query Filters"))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns")),(0,r.kt)("p",null,"This method does not return anything"),(0,r.kt)("h2",{id:"queryclientresetqueries"},(0,r.kt)("inlineCode",{parentName:"h2"},"queryClient.resetQueries")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"resetQueries")," method can be used to reset queries in the cache to their\ninitial state based on their query keys or any other functionally accessible\nproperty/state of the query."),(0,r.kt)("p",null,"This will notify subscribers ","\u2014"," unlike ",(0,r.kt)("inlineCode",{parentName:"p"},"clear"),", which removes all\nsubscribers ","\u2014"," and reset the query to its pre-loaded state ","\u2014"," unlike\n",(0,r.kt)("inlineCode",{parentName:"p"},"invalidateQueries"),". If a query has ",(0,r.kt)("inlineCode",{parentName:"p"},"initialData"),", the query's data will be\nreset to that. If a query is active, it will be refetched."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"queryClient.resetQueries(queryKey, { exact: true });\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Options")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"queryKey?: QueryKey"),": ",(0,r.kt)("a",{parentName:"li",href:"/react-query-web-i18n/react/guides&concepts/query-keys"},"Query Keys")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"filters?: QueryFilters"),": ",(0,r.kt)("a",{parentName:"li",href:"/react-query-web-i18n/react/guides&concepts/filters#query-filters"},"Query Filters"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"refetchPage: (page: TData, index: number, allPages: TData[]) => boolean"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Only for ",(0,r.kt)("a",{parentName:"li",href:"/react-query-web-i18n/react/guides&concepts/infinite-queries#refetchpage"},"Infinite Queries")),(0,r.kt)("li",{parentName:"ul"},"Use this function to specify which pages should be refetched"))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"options?: ResetOptions"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"throwOnError?: boolean"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"When set to ",(0,r.kt)("inlineCode",{parentName:"li"},"true"),", this method will throw if any of the query refetch tasks fail."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"cancelRefetch?: boolean"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Defaults to ",(0,r.kt)("inlineCode",{parentName:"li"},"true"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Per default, a currently running request will be cancelled before a new request is made"))),(0,r.kt)("li",{parentName:"ul"},"When set to ",(0,r.kt)("inlineCode",{parentName:"li"},"false"),", no refetch will be made if there is already a request running.")))))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns")),(0,r.kt)("p",null,"This method returns a promise that resolves when all active queries have been refetched."),(0,r.kt)("h2",{id:"queryclientisfetching"},(0,r.kt)("inlineCode",{parentName:"h2"},"queryClient.isFetching")),(0,r.kt)("p",null,"This ",(0,r.kt)("inlineCode",{parentName:"p"},"isFetching")," method returns an ",(0,r.kt)("inlineCode",{parentName:"p"},"integer")," representing how many queries, if any, in the cache are currently fetching (including background-fetching, loading new pages, or loading more infinite query results)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},'if (queryClient.isFetching()) {\n  console.log("At least one query is fetching!");\n}\n')),(0,r.kt)("p",null,"React Query also exports a handy ",(0,r.kt)("a",{parentName:"p",href:"../reference/useIsFetching"},(0,r.kt)("inlineCode",{parentName:"a"},"useIsFetching"))," hook that will let you subscribe to this state in your components without creating a manual subscription to the query cache."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Options")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"queryKey?: QueryKey"),": ",(0,r.kt)("a",{parentName:"li",href:"/react-query-web-i18n/react/guides&concepts/query-keys"},"Query Keys")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"filters?: QueryFilters"),": ",(0,r.kt)("a",{parentName:"li",href:"/react-query-web-i18n/react/guides&concepts/filters#query-filters"},"Query Filters"))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns")),(0,r.kt)("p",null,"This method returns the number of fetching queries."),(0,r.kt)("h2",{id:"queryclientismutating"},(0,r.kt)("inlineCode",{parentName:"h2"},"queryClient.isMutating")),(0,r.kt)("p",null,"This ",(0,r.kt)("inlineCode",{parentName:"p"},"isMutating")," method returns an ",(0,r.kt)("inlineCode",{parentName:"p"},"integer")," representing how many mutations, if any, in the cache are currently fetching."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},'if (queryClient.isMutating()) {\n  console.log("At least one mutation is fetching!");\n}\n')),(0,r.kt)("p",null,"React Query also exports a handy ",(0,r.kt)("a",{parentName:"p",href:"../reference/useIsMutating"},(0,r.kt)("inlineCode",{parentName:"a"},"useIsMutating"))," hook that will let you subscribe to this state in your components without creating a manual subscription to the mutation cache."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Options")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"filters: MutationFilters"),": ",(0,r.kt)("a",{parentName:"li",href:"/react-query-web-i18n/react/guides&concepts/filters#mutation-filters"},"Mutation Filters"))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns")),(0,r.kt)("p",null,"This method returns the number of fetching mutations."),(0,r.kt)("h2",{id:"queryclientgetlogger"},(0,r.kt)("inlineCode",{parentName:"h2"},"queryClient.getLogger")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"getLogger")," method returns the logger which have been set when creating the client."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const logger = queryClient.getLogger();\n")),(0,r.kt)("h2",{id:"queryclientgetdefaultoptions"},(0,r.kt)("inlineCode",{parentName:"h2"},"queryClient.getDefaultOptions")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"getDefaultOptions")," method returns the default options which have been set when creating the client or with ",(0,r.kt)("inlineCode",{parentName:"p"},"setDefaultOptions"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const defaultOptions = queryClient.getDefaultOptions();\n")),(0,r.kt)("h2",{id:"queryclientsetdefaultoptions"},(0,r.kt)("inlineCode",{parentName:"h2"},"queryClient.setDefaultOptions")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"setDefaultOptions")," method can be used to dynamically set the default options for this queryClient. Previously defined default options will be overwritten."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"queryClient.setDefaultOptions({\n  queries: {\n    staleTime: Infinity,\n  },\n});\n")),(0,r.kt)("h2",{id:"queryclientgetquerydefaults"},(0,r.kt)("inlineCode",{parentName:"h2"},"queryClient.getQueryDefaults")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"getQueryDefaults")," method returns the default options which have been set for specific queries:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},'const defaultOptions = queryClient.getQueryDefaults(["posts"]);\n')),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note that if several query defaults match the given query key, the ",(0,r.kt)("strong",{parentName:"p"},"first")," matching one is returned.\nThis could lead to unexpected behaviours. See ",(0,r.kt)("a",{parentName:"p",href:"#queryclientsetquerydefaults"},(0,r.kt)("inlineCode",{parentName:"a"},"setQueryDefaults")),".")),(0,r.kt)("h2",{id:"queryclientsetquerydefaults"},(0,r.kt)("inlineCode",{parentName:"h2"},"queryClient.setQueryDefaults")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"setQueryDefaults")," can be used to set default options for specific queries:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},'queryClient.setQueryDefaults(["posts"], { queryFn: fetchPosts });\n\nfunction Component() {\n  const { data } = useQuery(["posts"]);\n}\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Options")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"queryKey: QueryKey"),": ",(0,r.kt)("a",{parentName:"li",href:"/react-query-web-i18n/react/guides&concepts/query-keys"},"Query Keys")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"options: QueryOptions"))),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"As stated in ",(0,r.kt)("a",{parentName:"p",href:"#queryclientgetquerydefaults"},(0,r.kt)("inlineCode",{parentName:"a"},"getQueryDefaults")),", the order of registration of query defaults does matter.\nSince the ",(0,r.kt)("strong",{parentName:"p"},"first")," matching defaults are returned by ",(0,r.kt)("inlineCode",{parentName:"p"},"getQueryDefaults"),", the registration should be made in the following order: from the ",(0,r.kt)("strong",{parentName:"p"},"least generic key")," to the ",(0,r.kt)("strong",{parentName:"p"},"most generic one"),". This way, in case of specific key, the first matching one would be the expected one.")),(0,r.kt)("h2",{id:"queryclientgetmutationdefaults"},(0,r.kt)("inlineCode",{parentName:"h2"},"queryClient.getMutationDefaults")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"getMutationDefaults")," method returns the default options which have been set for specific mutations:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},'const defaultOptions = queryClient.getMutationDefaults(["addPost"]);\n')),(0,r.kt)("h2",{id:"queryclientsetmutationdefaults"},(0,r.kt)("inlineCode",{parentName:"h2"},"queryClient.setMutationDefaults")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"setMutationDefaults")," can be used to set default options for specific mutations:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},'queryClient.setMutationDefaults(["addPost"], { mutationFn: addPost });\n\nfunction Component() {\n  const { data } = useMutation(["addPost"]);\n}\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Options")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"mutationKey: string | unknown[]")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"options: MutationOptions"))),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Similar to ",(0,r.kt)("a",{parentName:"p",href:"#queryclientsetquerydefaults"},(0,r.kt)("inlineCode",{parentName:"a"},"setQueryDefaults")),", the order of registration does matter here.")),(0,r.kt)("h2",{id:"queryclientgetquerycache"},(0,r.kt)("inlineCode",{parentName:"h2"},"queryClient.getQueryCache")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"getQueryCache")," method returns the query cache this client is connected to."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const queryCache = queryClient.getQueryCache();\n")),(0,r.kt)("h2",{id:"queryclientgetmutationcache"},(0,r.kt)("inlineCode",{parentName:"h2"},"queryClient.getMutationCache")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"getMutationCache")," method returns the mutation cache this client is connected to."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const mutationCache = queryClient.getMutationCache();\n")),(0,r.kt)("h2",{id:"queryclientclear"},(0,r.kt)("inlineCode",{parentName:"h2"},"queryClient.clear")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"clear")," method clears all connected caches."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"queryClient.clear();\n")),(0,r.kt)("h2",{id:"queryclientresumepausedmutations"},(0,r.kt)("inlineCode",{parentName:"h2"},"queryClient.resumePausedMutations")),(0,r.kt)("p",null,"Can be used to resume mutations that have been paused because there was no network connection."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"queryClient.resumePausedMutations();\n")))}d.isMDXComponent=!0}}]);